- restart:
  - implement full decoder
  - consume byte channel
  - instruction channel return

  - instruction.go  : types for all instructions, initially just String() in the interface
    - requires supporting machine types
      - Src8 : place from which we can read a byte
      - Dst8 : place to which we can write a bute
      - Src16 : 16bit src
      - Dst16 : 16bit dst
    - need register concepts for String() repr
      - R8  : implement Src8, Dst8
      - R16 : implement Src16, Dst16
      - Imm8 : implement Src8
      - Imm16 : implement Src16
      - ImmAddr16 : implement Src16, Dst16
        - ??? or wrap an 'addr' around any other Src16/Dst16?
  - decode.go : consume byte stream, return instruction stream
    - we now have a disassembler (separate binary, operates on a file .bin->.z80)
  - assemble.go : string -> instruction
    - add Encode() to instruction too, and we can full-test the encode
    - new binary assemble .z80 file to .bin
  - zog.go : machine (registers, memory)

- maybe drop channel i/f to decode
  - or at least have it in terms of something else
  - also, don't stop decoding on decode error
    - report error, consume correct number of bytes, continue

- grab speccy book table for decode test
