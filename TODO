DONE - create a 'machine' interface
  - CP/M and Speccy
  - loaded by zog

- start on spectrum hardware
  DONE - add hardware interrupt hook
    - ei/di
    - im 0/1/2
  - how does machine run interrupt?
    // load ROMs, start hardware (including interrupt goro, screen refresh)
    DONE - machine.Start(z)
  - add keyboard IO ports
  - work out how to interrupt main loop to do screen refresh
  (happens progressively)
  DONE YES (maybe just have a 'tick' function to update screen)
  DONE (and call that in a time loop to start with)
  DONE - try loading a ROM
  - will need read-only memory at some pt


- could trigger "which key is being pressed" from input handlers
  - will work better for games



- Fix remaining z80test problems
  DONE - ldi/ldir/etc
  - LD A, I : LD A, R
  - super ops

- add some kind of ULA interrupt to read memory and display image
  - use SDL to draw image

DONE - write spectrum-like print routines for z80test

- find (and remove boilerplate) of the F_Z/F_S etc setting

- zexall
  - huh. of course CRC is only compared at the end of the run, so don't know
  which instruction in the batch error'd the CRC...

  - bug:
    RES/SET use InstU8 hence set S+Z flags
    (CP uses explicit save/restore to avoid)

  - impl add/adc16 with same exec helper
    - see if it passes zexall adc


- performance
  - don't allocate an executeTrace in each instruction execution
  instead, re-initialise the slot in the haltTrace ring buffer
  (different re-init may have different perf characteristics. e.g. map is normally entry
  or small, may be worth scan+delete rather than re-alloc empty)

DONE - redo mem watches as callback
  - so can hook into ET without checking every instruction

- consider working labels in assembler
  - JP foo, JR foo, LD A, (foo)



  - grab a ROM and see where it dies! (spectrum-roms ubuntu pkg)
  - try and find some example programs
  - write a test rom/prelude of some kind
    - use it if cmdline to execute given

  DONE - CP/M has simple I/O for zexall
    - add 'zexall/cp/m support' option
      - write some Z80 assembly
      - drive an I/O port to write chars
        - register I/O handlers

- write enable-able logging streams (e.g. 'Z:' logging for locations)
  - tagged logging streams?

- spin up http server (gop?)
  - serve machine state (num cycles, registers, ...?) over http
  - ? serve zx spectrum display image over ws?


- emulator
  - implement some debug hook (zexall compatible)
    - conout to write to console
    - RST 16 :-)
    - jp 0 to "reboot cp/m"


  - zexdoc
  - zexall

- add cmdline disassembler
  - try on some big files
  - add (made up) labels for jump targets in disassembler
  - add some directives (org, data bytes)
