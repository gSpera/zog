DONE - add Read/Write16 (want it to read (PC))

DONE - Add a Run loop
  DONE- single byte instructions initially
  DONE - fetch, then execute instrucion
  DONE- gah. ok, look at the loc8 bit patterns for other instructions and work out categories
  DONE (LD src, dest has different bit patterns for src and dest, work out how many funcs we need for 3bits => reg)

DONE - Add a LD8 instruction which copies a single byte
  DONE - register to register
  DONE - and immediate constant

DONE - Add basic assembler
  DONE - no need for labels yet
  DONE - need to expand instruction types with some kind of r, n, nn helpers
  DONE - instructions need to be able to Encode themselves

DONE - test code needs to:
  DONE - run emulator with "exit on halt" debug flag set
    - or run one instruction at a time
    - and have an IsHalted() method (interrupts could unhalt?)
    - peek reg A or something
  - testcases {"LD A, 10", 10}

DONE - have more tables (one table?!!?) for instructions
  DONE - instead of code to decode, have code to load the table !!!
  - want function pts in table too, for execute
    - could be closure, could be func which takes info and switches/decomposes

- pass byte channel or io.Reader to d.Decode

- work out if name should be a property on the type (String) or if
  better to call a method on decoder. If we do that, decoder probably doesn't
  need to be global

- write LD8 and Accum8 methods in terms of decoder lookup

- Have one LD8 type, which has a src and a dst
  - encode the src/dst part in a type (or closure!)
  - have a NewLD8 ctor which disallows the invalid combinations
  - rewrite decodeILD8 and ParseLD in terms of this
  - then move onto LD16

- rename IVarious to "INoArg" and make it entirely table driven
  - assembly name
  - encode bytes
  - decoder (once called from main decoder)
    - and actually, have the main decoder consult tables first too
  - execution (can use named functions or closures in table)

DONE - some structure around tests:
  DONE - assembly
  DONE - expected result in accum
  DONE - also want flags
    - return those?
    - or put in A?
      - return all regs from HALT?
      - or test inside the assembly?
      - or return flags?

- pull out a general "hi3" string <-> num for logic ops etc
  - and use it to initialise the MakeParseAccum in AssemblyParser

- factor out common helper functions for assembler
DONE - support more ops than ADD
- add tests for logic ops using assembler

DONE - add the arithmetic stuff
   - but parameterise the operation
   - so we don't have a type per instr
   - just a "two arg 8 bit"
   - and make LD an instance of it
   - pass in a func() to do the work on the ops?

- add some ad hoc tests for logic and arith ops
  - include desired flag outputs
    (set, cleared, unchanged (two tests needed!)) for all relephant flags

- add more complete flag handling
  - and some tests

- Add a RST16 hack which debug-prints contents of A?
  - need a way to run until test

- write a program which stores 0x16 to A then prints it


- add INC8 and DEC8

- add (HL) address mode to R8Loc

- add LD16, INC16, DEC16

- add DJNZ

- interrupts

profit

- go-gl visualiser. registers, memory reads+writes, fading over time

- spectrum emulator:
  - go-gl bitmapped spectrum display
  - keyboard
  - other I/O
  - spectrum ROM
