- implement LD16
  - copy code from INC16
  - Use Loc16 everywhere
  - pull into helpers

  - do we use any table apart from tableR?
    - can we drop that type and the panic() check?

- implement Encode() for instructions

- might have displacement byte in the wrong place for CB-prefix:
  "These instructions have the following format:
    DD or FD prefix,  CB,  displacement byte,  opcode"
  - check by hand against z80asm
  - ??? have autotests run z80asm/z80dasm and compare?

DONE - add encode tests (driven by 'all' table)

- find a way to share Encode() between simple InstU8?
  (e.g. INC/DEC/ALU)


DONE - imple inspect/encodeHelper  for InstBin8
  - refactor (interface?) to share code with InstU8

- allow 0x10 and 10h representations for IX offset, for encode testing

- consider collapsing src/dst8 into loc8, ditto loc16

DONE - consider have unary/binary embeddable instruction bases
  - encode helper can examine loc for IX etc
    - also need to encode displacement!
  - or just helper method?
    - take optional src + dst (or nil)


- add round trip tests
  - string -> assemble2instruction -> encode2bytes-> decode2instruction -> .String()2string
  - we'll need to handle non-injective maps (bytes -> string?)
  - needed to help trap the indexed CB prefix bug (displacement in wrong place)

- panic on write to imm8

- assembler needs Encode() on Instruction
  - drive via same all tests
  - or as part of decode test loop?
    buf -> inst         ; decode
    inst -> string      ; disass
    string -> inst      ; ass
    inst -> buf         ; encode

- add cmdline disassembler
  - try on some big files
  - add (made up) labels for jump targets in disassembler

DONE - implement ED

- implement DDCB+FDCB

DONE - grab speccy book table for decode test
